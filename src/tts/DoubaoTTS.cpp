#include "DoubaoTTS.h"#include "ArduinoJson.h"#include "utils.h"#include "driver/i2s.h"#include "freertos/task.h"#include "Arduino.h"#include <vector>#include "Settings.h"#include "Application.h"#include "AudioPlayer.h"#include "GlobalState.h"constexpr uint8_t defaultHeader[] = {0x11, 0x10, 0x10, 0x00};static auto TAG = "TTS";DoubaoTTS::DoubaoTTS() {    _taskFinished = xSemaphoreCreateBinary();    begin();}void DoubaoTTS::eventCallback(const WStype_t type, uint8_t *payload, const size_t length) {    switch (type) {        case WStype_PING:        case WStype_ERROR:        case WStype_CONNECTED:        case WStype_DISCONNECTED:        case WStype_TEXT:            break;        case WStype_BIN:            parseResponse(payload);            break;        default:            break;    }}String DoubaoTTS::buildFullClientRequest(const String &text) {    JsonDocument params;    const JsonObject app = params["app"].to<JsonObject>();    app["appid"] = Settings::getDoubaoAppId();    app["token"] = Settings::getDoubaoAccessToken();    app["cluster"] = "volcano_tts";    const JsonObject user = params["user"].to<JsonObject>();    user["uid"] = getChipId(nullptr);    const JsonObject audio = params["audio"].to<JsonObject>();    std::map<std::string, std::string> voiceMap = Settings::getVoiceMap();    std::string voiceType = voiceMap[Settings::getCurrentVoice().c_str()];    if (voiceType.empty()) {        // 默认使用湾湾小河的声音        voiceType = "zh_female_wanwanxiaohe_moon_bigtts";    }    audio["voice_type"] = voiceType;    audio["encoding"] = "pcm";    audio["rate"] = 16000;    audio["speed_ratio"] = Settings::getCurrentSpeakSpeedRatio();    // 固定以最大音量进行语音合成，至于音量，后面再二次调整    audio["volume_ratio"] = 2;    const JsonObject request = params["request"].to<JsonObject>();    request["reqid"] = generateTaskId();    request["text"] = text;    request["operation"] = "submit";    String resStr;    serializeJson(params, resStr);    return resStr;}void DoubaoTTS::synth(const String &text, const bool disconnectAfter) {    if (text.isEmpty()) {        return;    }    _taskStartTime = millis();    ESP_LOGI(TAG, "开始语音合成：%s", text.c_str());    while (!isConnected()) {        connect();        vTaskDelay(1);    }    const String payloadStr = buildFullClientRequest(text);    uint8_t payload[payloadStr.length()];    for (int i = 0; i < payloadStr.length(); i++) {        payload[i] = static_cast<uint8_t>(payloadStr.charAt(i));    }    payload[payloadStr.length()] = '\0';    const uint32_t payloadSize = payloadStr.length();    std::vector<uint8_t> payloadLength = uint32ToUint8Array(payloadSize);    std::vector<uint8_t> clientRequest(defaultHeader, defaultHeader + sizeof(defaultHeader));    clientRequest.insert(clientRequest.end(), payloadLength.begin(), payloadLength.end());    clientRequest.insert(clientRequest.end(), payload, payload + sizeof(payload));    if (!sendBIN(clientRequest.data(), clientRequest.size())) {        ESP_LOGE(TAG, "发送语音合成请求失败: %s", text.c_str());        xSemaphoreGive(_taskFinished);        return;    }    while (xSemaphoreTake(_taskFinished, 0) == pdFALSE) {        loop();        vTaskDelay(1);    }    if (disconnectAfter) {        disconnect();    }}void DoubaoTTS::parseResponse(const uint8_t *response) const {    const uint8_t messageType = response[1] >> 4;    const uint8_t messageTypeSpecificFlags = response[1] & 0x0f;    const uint8_t *payload = response + 4;    switch (messageType) {        case 0b1011: {            // 0b1011 - Audio-only server response (ACK).            if (messageTypeSpecificFlags > 0) {                const auto sequenceNumber = readInt32(payload);                const auto payloadSize = readInt32(payload + 4);                if (payloadSize > 0) {                    payload += 8;                    PlayAudioTask task{};                    task.length = payloadSize / sizeof(int16_t);                    task.data = static_cast<int16_t *>(ps_malloc(payloadSize));                    memcpy(task.data, payload, payloadSize);                    Application::audioPlayer()->publishTask(task);                }                if (sequenceNumber < 0) {                    xSemaphoreGive(_taskFinished);                }            }            break;        }        case 0b1111: {            // Error message from server (例如错误的消息类型，不支持的序列化方法等等)            const uint8_t errorCode = readInt32(payload);            const uint8_t messageSize = readInt32(payload + 4);            const unsigned char *errMessage = payload + 8;            ESP_LOGE(TAG, "语音合成失败, code: %d, reason: %s", errorCode, String(errMessage, messageSize).c_str());            xSemaphoreGive(_taskFinished);            break;        }        default:            break;    }}void DoubaoTTS::begin() {    setExtraHeaders(("Authorization: Bearer; " + Settings::getDoubaoAccessToken()).c_str());    beginSSL("openspeech.bytedance.com", 443, "/api/v1/tts/ws_binary");    onEvent([this](WStype_t type, uint8_t *payload, size_t length) {        this->eventCallback(type, payload, length);    });}// 创建websocket连接void DoubaoTTS::connect() {    if (isConnected() || _isConnecting) return;    _isConnecting = true;    xTaskCreate([](void *args) {        auto *self = static_cast<DoubaoTTS *>(args);        while (!self->isConnected()) {            self->loop();            vTaskDelay(pdMS_TO_TICKS(1));        }        self->_isConnecting = false;        vTaskDelete(nullptr);    }, "DoubaoTTSConnect", 4096, this, 1, nullptr);}